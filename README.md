# TruckCo — Azure web server deployment (Terraform + Ansible)

This repository demonstrates an automated, best-practice deployment of a Linux web server on Azure using **Terraform** (infrastructure provisioning) and **Ansible** (configuration management). The server is a starter footprint for a trucking logistics application (TruckCo).

---

## What this repo creates

- Azure Resource Group
- Virtual Network + Subnet
- Network Security Group (NSG)
  - Allow SSH (port 22) **from your IP only** (CIDR).
  - Allow HTTP (port 80) from anywhere.
  - Default Azure NSG inbound deny for other traffic.
- Public static IP
- Network Interface
- Linux VM (Ubuntu LTS)
- Terraform will write an Ansible inventory file with the VM public IP so you can run the Ansible playbook automatically.

Ansible will:
- Update system packages
- Disable root login and password-based SSH auth (enforce key-based)
- Install and enable `nginx`
- Deploy a simple `index.html` to `/var/www/html/`
- Install and configure `ufw` to allow SSH and HTTP only

---

## Repository structure

truckco-azure-deploy/
├─ ansible/
│ ├─ playbook.yml
│ └─ files/index.html
├─ terraform/
│ ├─ main.tf
│ ├─ variables.tf
│ ├─ outputs.tf
│ ├─ providers.tf
│ └─ versions.tf
├─ .gitignore
└─ README.md


---

## Prerequisites

1. **Azure account** with permission to create resources (VMs, networking, IPs, resource groups).
2. **Azure CLI** installed and logged in:

   ```bash
   az login
   az account set --subscription "your-subscription-id-or-name"

3. **Terraform (>= 1.2).**
4. **Ansible (>= 2.9 recommended).**
5. **SSH key pair on your workstation. Example generate:**

    ```bash
    ssh-keygen -t ed25519 -f ~/.ssh/truckco -C "truckco"

    - Public key path: ~/.ssh/truckco.pub
    - Private key path: ~/.ssh/truckco

Terraform will inject the public key into the VM to allow key-based login as the admin user.

How to run
1) Prepare variables

Edit terraform/terraform.tfvars OR pass -var values. A sample terraform/terraform.tfvars.example is provided.

Make sure to set my_ip_cidr to your current public IP in CIDR form (e.g. 203.0.113.45/32). This will allow SSH from your IP only.

2) Authenticate to Azure

Use Azure CLI:

az login
az account set --subscription "YOUR_SUBSCRIPTION_ID"

(Alternatively you can use service principal environment variables if CI/CD or automation is required — see "CI / Remote state & automation" below.)

3) Terraform init / apply

Change to the terraform directory:

cd terraform
terraform init
terraform plan -out plan.tfplan
terraform apply "plan.tfplan"

Terraform will:

Create the infra

Generate ansible/hosts.ini with the VM public IP (path configurable via ansible_inventory_path variable)

Example ansible/hosts.ini generated:

[truckco]
20.30.40.50 ansible_user=truckcoadmin

4) Run Ansible playbook

Back in the repo root:

# Use the private key that pairs with the public key you supplied to Terraform
ansible-playbook -i terraform/../ansible/hosts.ini ansible/playbook.yml --private-key ~/.ssh/truckco


This runs the playbook against the VM, installing nginx, configuring SSH and UFW, and dropping the index.html file.

5) Verify

Visit http://<PUBLIC_IP> in your browser. You should see my personal message.

Important variables & tips

    - my_ip_cidr — must be your public IP in CIDR format (e.g., 203.0.113.45/32). If you leave it open (not recommended), SSH is exposed to the world.
    - ssh_public_key_path — path to the public key file used to inject into VM.
    - Use strong, unique admin_username (avoid azureuser or root).

Design decisions & rationale (brief)

    - Terraform for infra & Ansible for config — standard separation of concerns. Terraform creates immutable infra; Ansible configures software/state.
    - NSG on subnet — simpler to manage for this single-VM scenario; isolates network-level controls.
    - SSH restricted to your IP — protects the VM from internet-wide SSH brute force.
    - Key-based SSH only / disable root — OS-level hardening best practice.
    - UFW in addition to NSG — defense-in-depth: cloud-level NSG + host-level firewall.
    - Ansible inventory generated by Terraform — automation-friendly; no manual copy of IP needed.
    - Static public IP (Standard SKU) — stable IP for DNS and future usage.

CI / Remote state & automation (optional)

For team usage or GitHub Actions:
    - Configure a Terraform backend using an Azure Storage account container (azurerm backend).
    - Use a service principal to authenticate Terraform/CI:

    az ad sp create-for-rbac --name "tf-sp-xyz" --role="Contributor" --scopes="/subscriptions/..."

    Then set ARM_CLIENT_ID, ARM_CLIENT_SECRET, ARM_TENANT_ID, ARM_SUBSCRIPTION_ID in CI secrets.

Cleanup

To destroy all created resources:

cd terraform
terraform destroy

Security notes

Do not commit private keys to the repository.

Keep your my_ip_cidr up to date if your IP changes.

Consider using Azure Bastion or VPN for production instead of direct public SSH.

Troubleshooting

If Terraform errors on provider versions, upgrade/downgrade your azurerm provider to match your Terraform version.

If Ansible can't connect: check ansible_user in the generated hosts file, ensure you are using the correct private key and your my_ip_cidr matches the public IP of your client machine.

Next steps (suggestions)

Put the Terraform state in an Azure Storage backend for teams.

Add Azure Managed Identities for the VM if it needs access to other Azure resources.

Add a managed load balancer and an autoscale group for production.

Add TLS (Let's Encrypt) and DNS records for your domain.
